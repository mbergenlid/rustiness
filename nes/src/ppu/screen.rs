
pub type Color = (u8, u8, u8);

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub struct Tile {
    pub pattern_index: u32,
    pub palette_index: u8
}

#[derive(Eq, PartialEq, Clone, Copy)]
pub struct Pattern {
    pub data: [[u8; 8]; 8],
}

use std::fmt;
use std::fmt::Debug;
impl Debug for Pattern {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for row in self.data.iter() {
            writeln!(f, "{:?}", row).expect("Failed to write");
        }
        Ok(())
    }
}

pub struct PixelBuffer<'a> {
    pub buffer: &'a mut [u8],
    pub pitch: usize,
    pub scale: u8,
}

impl <'a> PixelBuffer<'a> {
    pub fn set_pixel(&mut self, x: usize, y: usize, colour: (u8, u8, u8)) {
        let scale = self.scale as usize;
        let offset = y*self.pitch*scale + x*3*scale;
        self.buffer[offset + 0] = colour.0;
        self.buffer[offset + 1] = colour.1;
        self.buffer[offset + 2] = colour.2;

//        self.buffer[offset + 3] = colour.0;
//        self.buffer[offset + 4] = colour.1;
//        self.buffer[offset + 5] = colour.2;

//        self.buffer[offset + self.pitch + 0] = colour.0;
//        self.buffer[offset + self.pitch + 1] = colour.1;
//        self.buffer[offset + self.pitch + 2] = colour.2;
//        self.buffer[offset + self.pitch + 3] = colour.0;
//        self.buffer[offset + self.pitch + 4] = colour.1;
//        self.buffer[offset + self.pitch + 5] = colour.2;
    }
}

pub trait Screen {
    fn draw<T>(&mut self, func: T) where Self: Sized, T: FnOnce(&mut PixelBuffer);
}

pub struct ScreenMock {}

impl ScreenMock {
    pub fn new() -> ScreenMock {
        ScreenMock {}
    }
}

impl Screen for ScreenMock {
    fn draw<T>(&mut self, _: T) where T: FnOnce(&mut PixelBuffer) {
    }
}

pub const BLACK: Color = (0, 0, 0);
pub const WHITE: Color = (1, 1, 1);

pub const COLOUR_PALETTE: [Color; 0x40] = [
    (0x75, 0x75, 0x75), //0x00
    (0x27, 0x1B, 0x8F), //0x01
    (0x00, 0x00, 0xAB), //0x02
    (0x47, 0x00, 0x9F), //0x03
    (0x8F, 0x00, 0x77), //0x04
    (0xAB, 0x00, 0x13), //0x05
    (0xA7, 0x00, 0x00), //0x06
    (0x7F, 0x0B, 0x00), //0x07
    (0x43, 0x2F, 0x00), //0x08
    (0x00, 0x47, 0x00), //0x09
    (0x00, 0x51, 0x00), //0x0A
    (0x00, 0x3F, 0x17), //0x0B
    (0x1B, 0x3F, 0x5F), //0x0C
    (0x00, 0x00, 0x00), //0x0D
    (0x00, 0x00, 0x00), //0x0E
    (0x00, 0x00, 0x00), //0x0F
    (0xBC, 0xBC, 0xBC), //0x10
    (0x00, 0x73, 0xEF), //0x11
    (0x23, 0x3B, 0xEF), //0x12
    (0x83, 0x00, 0xF3), //0x13
    (0xBF, 0x00, 0xBF), //0x14
    (0xE7, 0x00, 0x5B), //0x15
    (0xDB, 0x2B, 0x00), //0x16
    (0xCB, 0x4F, 0x0F), //0x17
    (0x8B, 0x73, 0x00), //0x18
    (0x00, 0x97, 0x00), //0x19
    (0x00, 0xAB, 0x00), //0x1A
    (0x00, 0x93, 0x3B), //0x1B
    (0x00, 0x83, 0x8B), //0x1C
    (0x00, 0x00, 0x00), //0x1D
    (0x00, 0x00, 0x00), //0x1E
    (0x00, 0x00, 0x00), //0x1F
    (0xFF, 0xFF, 0xFF), //0x20
    (0x3F, 0xBF, 0xFF), //0x21
    (0x5F, 0x97, 0xFF), //0x22
    (0xA7, 0x8B, 0xFD), //0x23
    (0xF7, 0x7B, 0xFF), //0x24
    (0xFF, 0x77, 0xB7), //0x25
    (0xFF, 0x77, 0x63), //0x26
    (0xFF, 0x9B, 0x3B), //0x27
    (0xF3, 0xBF, 0x3F), //0x28
    (0x83, 0xD3, 0x13), //0x29
    (0x4F, 0xDF, 0x4B), //0x2A
    (0x58, 0xF8, 0x98), //0x2B
    (0x00, 0xEB, 0xDB), //0x2C
    (0x00, 0x00, 0x00), //0x2D
    (0x00, 0x00, 0x00), //0x2E
    (0x00, 0x00, 0x00), //0x2F
    (0xFF, 0xFF, 0xFF), //0x30
    (0xAB, 0xE7, 0xFF), //0x31
    (0xC7, 0xD7, 0xFF), //0x32
    (0xD7, 0xCB, 0xFF), //0x33
    (0xFF, 0xC7, 0xFF), //0x34
    (0xFF, 0xC7, 0xDB), //0x35
    (0xFF, 0xBF, 0xB3), //0x36
    (0xFF, 0xDB, 0xAB), //0x37
    (0xFF, 0xE7, 0xA3), //0x38
    (0xE3, 0xFF, 0xA3), //0x39
    (0xAB, 0xF3, 0xBF), //0x3A
    (0xB3, 0xFF, 0xCF), //0x3B
    (0x9F, 0xFF, 0xF3), //0x3C
    (0x00, 0x00, 0x00), //0x3D
    (0x00, 0x00, 0x00), //0x3E
    (0x00, 0x00, 0x00), //0x3F

];